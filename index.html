<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Basketball - Analyse Coach</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /*background: linear-gradient(135deg, #ffffff 0%, #d5d5d5 100%);*/
			
			/*background: radial-gradient(circle, #e63946, #457b9d, #1d3557, #1d3557, #457b9d, #e63946);
			background-size: 2000% 2000%;
			animation: gradientShift 200s ease infinite;
			background-position: center;*/
			
			
			background: radial-gradient(circle, #ffffff, #414141, #000000);
			background-size: 1000% 1000%;
			animation: gradientShift 5s 
			ease-in-out infinite;
			background-position: center;
			
			margin: 0;
			
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            font-weight: 400;
        }

        .filters-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 5px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .filters-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 1.3rem;
            font-weight: 600;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-control {
            padding: 12px 15px;
            border: 2px solid #e8e8e8;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            transition: all 0.3s ease;
            outline: none;
        }

        .filter-control:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .checkbox-item:hover {
            background: #e9ecef;
        }

        .checkbox-item.active {
            background: #3498db;
            color: white;
            /*border-color: #2980b9;*/
			box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .checkbox-item input {
            display: none;
        }

        .stats-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 0 5px 5px 0;
            padding: 25px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            /*border: 1px solid rgba(255, 255, 255, 0.2);*/
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .stat-icon {
            width: 50px;
            height: 50px;
            margin: 0 auto 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #7f8c8d;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.9rem;
        }

        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 5px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: 400px; /* Hauteur fixe */
        }

        .chart-container canvas {
            max-height: 320px !important; /* Hauteur fixe pour les canvas */
        }

        .chart-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .players-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 5px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .player-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 5px;
            padding: 20px;
            border-left: 5px solid #3498db;
            transition: all 0.3s ease;
        }

        .player-card:hover {
            transform: translateX(5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .player-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 15px;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: #2c3e50;
			margin-right: 10px;
        }

        .player-number {
            background: #3498db;
            color: white;
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .player-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .player-stat {
            text-align: center;
            padding: 8px;
            background: white;
            border-radius: 8px;
        }

        .player-stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .player-stat-label {
            font-size: 0.8rem;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        .no-data {
            text-align: center;
            color: #7f8c8d;
            font-style: italic;
            padding: 40px;
        }

        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .filters-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }

        .category-config-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 13px;
            cursor: move;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            margin-bottom: 8px;
            user-select: none;
        }

        .category-config-item:hover {
            background: #e9ecef;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .category-config-item.positive {
            background: rgba(44, 90, 160, 0.1);
            border-color: #2c5aa0;
            color: #2c5aa0;
        }

        .category-config-item.negative {
            background: rgba(220, 38, 38, 0.1);
            border-color: #dc2626;
            color: #dc2626;
        }

        .category-config-item.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
        }

        .category-drop-zone {
            min-height: 100px;
            border: 2px dashed #bdc3c7;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .category-drop-zone.drag-over {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.05);
        }

        .category-drop-zone.positive {
            border-color: #2c5aa0;
        }

        .category-drop-zone.negative {
            border-color: #dc2626;
        }

        .remove-from-category {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }

        .remove-from-category:hover {
            background: #c0392b;
        }
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

	
        .reset-filters:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
			
        }
		
		
        .file-upload {
            margin-bottom: 20px;
        }

        .file-upload-area {
            border: 2px dashed #bdc3c7;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
        }

        .file-upload-area:hover {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.05);
        }

        .file-upload-area.dragover {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

		.uncategorized-section {
			background: rgba(255, 255, 255, 0.95);
			backdrop-filter: blur(10px);
			border-radius: 12px;
			padding: 20px;
			box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
			border: 1px solid rgba(255, 255, 255, 0.2);
			width: 100%;
			margin-top: 20px;
		}

		.uncategorized-actions {
			transition: all 0.3s ease;
			width: 100%;
		}

		.category-config-item.uncategorized:hover {
			background: #f8f9fa !important;
			transform: translateY(-1px);
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		}


        #csvFileInput {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🏀 Dashboard Basketball</h1>
            <p class="subtitle">Analyse des performances pour le basket</p>
        </div>

        <!-- Upload CSV -->
        <div class="file-upload">
            <div class="file-upload-area" onclick="document.getElementById('csvFileInput').click()" 
                 ondrop="handleFileDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                <p><strong>📁 Cliquez ici ou glissez votre fichier CSV</strong></p>
                <p>Format attendu: Date,Adversaire,Joueur,Numéro,Quart-temps,Temps,Action</p>
                <input type="file" id="csvFileInput" accept=".csv" onchange="handleFileUpload(event)">
            </div>
        </div>

        <!-- Filtres -->
        <div class="filters-section">
            <div class="filters-title">
                🔍 Filtres Multi-Critères
            </div>
            <div class="filters-grid">
                <div class="filter-group">
                    <label>Date du match</label>
                    <select id="dateFilter" class="filter-control" onchange="applyFilters()">
                        <option value="">Toutes les dates</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Adversaire</label>
                    <select id="adversaireFilter" class="filter-control" onchange="applyFilters()">
                        <option value="">Tous les adversaires</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Quart-temps</label>
                    <select id="quartFilter" class="filter-control" onchange="applyFilters()">
                        <option value="">Tous les quart-temps</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Joueurs sélectionnés</label>
                    <div id="playersCheckboxes" class="checkbox-group">
                        <!-- Dynamiquement rempli -->
                    </div>
                </div>
            </div>
            <div class="filter-group">
                <label>Actions à analyser</label>
                <div id="actionsCheckboxes" class="checkbox-group">
                    <!-- Dynamiquement rempli -->
                </div>
            </div>
            <button class="reset-filters" onclick="resetAllFilters()" style="padding:10px;margin-top:10px;border-radius:5px">🔄 Réinitialiser tous les filtres</button>
        </div>

        <!-- Configuration des catégories -->
        <div class="filters-section">
            <div class="filters-title">
                ⚙️ Configuration des catégories d'actions
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 20px;">
                <div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <div style="width: 20px; height: 20px; background: #2c5aa0; border-radius: 4px;"></div>
                        <label style="font-weight: 600; color: #2c5aa0; font-size: 1.1rem;">Actions Positives</label>
                    </div>
                    <div id="positiveActionsConfig" class="checkbox-group">
                        <!-- Dynamiquement rempli -->
                    </div>
                </div>
                <div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <div style="width: 20px; height: 20px; background: #dc2626; border-radius: 4px;"></div>
                        <label style="font-weight: 600; color: #dc2626; font-size: 1.1rem;">Actions Négatives</label>
                    </div>
                    <div id="negativeActionsConfig" class="checkbox-group">
                        <!-- Dynamiquement rempli -->
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 5px; border-left: 4px solid #3498db;">
                <p style="margin: 0; color: #2c3e50; font-size: 0.9rem;">
                    <strong>💡 Astuce :</strong> Glissez les actions entre les catégories pour personnaliser votre analyse. 
                    Les actions non catégorisées n'apparaîtront que dans les graphiques généraux.
                </p>
            </div>
            <button class="reset-filters" onclick="resetCategorization()" style="background: #e67e22;padding:10px;margin-top:10px;border-radius:5px">
                🔄 Réinitialiser la catégorisation
            </button>
        </div>

        <!-- Vue d'ensemble statistiques -->
        <div class="stats-overview" id="statsOverview">
            <div class="stat-card">
                <div class="stat-icon">🎯</div>
                <div class="stat-value" id="totalActions">0</div>
                <div class="stat-label">Actions totales</div>
            </div>
            <div class="stat-card">
                <div class="stat-icon">⚡</div>
                <div class="stat-value" id="totalPoints">0</div>
                <div class="stat-label">Points marqués</div>
            </div>
            <div class="stat-card" style="border-left: 8px solid #2c5aa0;">
                <div class="stat-icon" style="background: linear-gradient(135deg, #2c5aa0, #1e3a8a);">✅</div>
                <div class="stat-value" id="positiveActions" style="color: #2c5aa0;">0</div>
                <div class="stat-label">Actions positives</div>
            </div>
            <div class="stat-card" style="border-left: 8px solid #dc2626;">
                <div class="stat-icon" style="background: linear-gradient(135deg, #dc2626, #991b1b);">❌</div>
                <div class="stat-value" id="negativeActions" style="color: #dc2626;">0</div>
                <div class="stat-label">Actions négatives</div>
            </div>
            <div class="stat-card">
                <div class="stat-icon">👥</div>
                <div class="stat-value" id="activePlayersCount">0</div>
                <div class="stat-label">Joueurs actifs</div>
            </div>
            <div class="stat-card">
                <div class="stat-icon">🏆</div>
                <div class="stat-value" id="matchesCount">0</div>
                <div class="stat-label">Matchs analysés</div>
            </div>
        </div>

        <!-- Graphiques -->
        <div class="charts-section">
            <div class="chart-container">
                <div class="chart-title">📊 Performance par joueur (positives vs négatives)</div>
                <canvas id="playersChart" width="400" height="300"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">⏰ Performance par quart-temps (positives vs négatives)</div>
                <canvas id="quartersChart" width="400" height="300"></canvas>
            </div>
        </div>

        <div class="charts-section">
            <div class="chart-container">
                <div class="chart-title">🎯 Types d'actions</div>
                <canvas id="actionsChart" width="400" height="300"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">📈 Évolution temporelle (positives vs négatives)</div>
                <canvas id="timelineChart" width="400" height="300"></canvas>
            </div>
        </div>

        <div class="charts-section">
            <div class="chart-container">
                <div class="chart-title">🏆 Classement joueurs par performance (différentiel)</div>
                <canvas id="performanceRankingChart" width="400" height="300"></canvas>
            </div>
            <div class="chart-container">
                <div class="chart-title">📊 Répartition équilibre/déséquilibre</div>
                <canvas id="balanceChart" width="400" height="300"></canvas>
            </div>
        </div>

        <!-- Détail des joueurs -->
        <div class="players-section">
            <div class="chart-title">👤 Analyse détaillée des joueurs</div>
            <div class="players-grid" id="playersGrid">
                <!-- Dynamiquement rempli -->
            </div>
        </div>
    </div>

    <script>
        let basketballData = [];
        let filteredData = [];
        let charts = {};
        let customPositiveActions = [];
        let customNegativeActions = [];

        // Initialisation sans données par défaut
        window.onload = function() {
            initializeEmptyDashboard();
        };

        // Gestion des fichiers
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file && file.type === 'text/csv') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseCSVData(e.target.result);
                };
                reader.readAsText(file);
            }
        }

        function handleFileDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            const file = event.dataTransfer.files[0];
            if (file && file.type === 'text/csv') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseCSVData(e.target.result);
                };
                reader.readAsText(file);
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        // Initialiser le dashboard vide
        function initializeEmptyDashboard() {
            basketballData = [];
            filteredData = [];
            
            // Vider tous les filtres
            document.getElementById('dateFilter').innerHTML = '<option value="">Toutes les dates</option>';
            document.getElementById('adversaireFilter').innerHTML = '<option value="">Tous les adversaires</option>';
            document.getElementById('quartFilter').innerHTML = '<option value="">Tous les quart-temps</option>';
            document.getElementById('playersCheckboxes').innerHTML = '<p style="color: #7f8c8d; font-style: italic;">Aucun joueur disponible</p>';
            document.getElementById('actionsCheckboxes').innerHTML = '<p style="color: #7f8c8d; font-style: italic;">Aucune action disponible</p>';
            
            // Initialiser les stats à zéro
            updateStats();
            
            // Initialiser les graphiques vides
            initializeEmptyCharts();
            
            // Vider la configuration des catégories
            document.getElementById('positiveActionsConfig').innerHTML = '<p style="color: #7f8c8d; font-style: italic;">Aucune action disponible</p>';
            document.getElementById('negativeActionsConfig').innerHTML = '<p style="color: #7f8c8d; font-style: italic;">Aucune action disponible</p>';
            
            // Réinitialiser les catégories personnalisées
            customPositiveActions = [];
            customNegativeActions = [];
            document.getElementById('playersGrid').innerHTML = '<div class="no-data">Importez un fichier CSV pour commencer l\'analyse</div>';
        }
        function parseCSVData(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            basketballData = lines.slice(1).map(line => {
                const values = line.split(',').map(v => v.trim());
                const obj = {};
                headers.forEach((header, index) => {
                    obj[header] = values[index];
                });
                return obj;
            });

            filteredData = [...basketballData];
            initializeFilters();
            updateDashboard();
        }

        // Initialiser les filtres
        function initializeFilters() {
            // Dates
            const dates = [...new Set(basketballData.map(d => d.Date))].sort();
            const dateSelect = document.getElementById('dateFilter');
            dateSelect.innerHTML = '<option value="">Toutes les dates</option>';
            dates.forEach(date => {
                dateSelect.innerHTML += `<option value="${date}">${new Date(date).toLocaleDateString('fr-FR')}</option>`;
            });

            // Adversaires
            const adversaires = [...new Set(basketballData.map(d => d.Adversaire))].sort();
            const adversaireSelect = document.getElementById('adversaireFilter');
            adversaireSelect.innerHTML = '<option value="">Tous les adversaires</option>';
            adversaires.forEach(adv => {
                adversaireSelect.innerHTML += `<option value="${adv}">${adv}</option>`;
            });

            // Quart-temps
            const quarters = [...new Set(basketballData.map(d => d['Quart-temps']))].sort();
            const quartSelect = document.getElementById('quartFilter');
            quartSelect.innerHTML = '<option value="">Tous les quart-temps</option>';
            quarters.forEach(q => {
                quartSelect.innerHTML += `<option value="${q}">${q}</option>`;
            });

            // Joueurs (checkboxes)
            const players = [...new Set(basketballData.map(d => d.Joueur))].sort();
            const playersContainer = document.getElementById('playersCheckboxes');
            playersContainer.innerHTML = '';
            players.forEach(player => {
                const div = document.createElement('div');
                div.className = 'checkbox-item active';
                div.innerHTML = `<input type="checkbox" id="player-${player}" checked onchange="applyFilters()"> ${player}`;
                div.onclick = function() {
                    const checkbox = div.querySelector('input');
                    checkbox.checked = !checkbox.checked;
                    div.classList.toggle('active', checkbox.checked);
                    applyFilters();
                };
                playersContainer.appendChild(div);
            });

            // Actions (checkboxes)
            const actions = [...new Set(basketballData.map(d => d.Action))].sort();
            const actionsContainer = document.getElementById('actionsCheckboxes');
            actionsContainer.innerHTML = '';
            actions.forEach(action => {
                const div = document.createElement('div');
                div.className = 'checkbox-item active';
                div.innerHTML = `<input type="checkbox" id="action-${action}" checked onchange="applyFilters()"> ${action}`;
                div.onclick = function() {
                    const checkbox = div.querySelector('input');
                    checkbox.checked = !checkbox.checked;
                    div.classList.toggle('active', checkbox.checked);
                    applyFilters();
                };
                actionsContainer.appendChild(div);
            });

            // Initialiser la configuration des catégories
            initializeCategoryConfiguration();
        }

        // Initialiser la configuration des catégories
        function initializeCategoryConfiguration() {
            if (basketballData.length === 0) return;
            
            const allActions = [...new Set(basketballData.map(d => d.Action))].sort();
            updateCategoryConfiguration(allActions);
        }

     
	function updateCategoryConfiguration(allActions) {
    const positiveContainer = document.getElementById('positiveActionsConfig');
    const negativeContainer = document.getElementById('negativeActionsConfig');
    
    // Vider les conteneurs
    positiveContainer.innerHTML = '';
    negativeContainer.innerHTML = '';
    
    // Supprimer toute section non catégorisée existante
    const existingUncategorized = document.querySelector('.uncategorized-section');
    if (existingUncategorized) {
        existingUncategorized.remove();
    }
    
    // Si aucune configuration personnalisée, utiliser les valeurs par défaut
    if (customPositiveActions.length === 0 && customNegativeActions.length === 0) {
        customPositiveActions = ['1 Point','2 Points', '3 Points', 'Passes décisive', 'Rebond', 'Interceptions']
            .filter(action => allActions.includes(action));
        customNegativeActions = ['Fautes', 'Perte de balle']
            .filter(action => allActions.includes(action));
    }
    
    // Actions positives
    customPositiveActions.forEach(action => {
        const div = createCategoryItem(action, 'positive');
        positiveContainer.appendChild(div);
    });
    
    // Actions négatives
    customNegativeActions.forEach(action => {
        const div = createCategoryItem(action, 'negative');
        negativeContainer.appendChild(div);
    });
    
    // Actions non catégorisées
    const uncategorizedActions = allActions.filter(action => 
        !customPositiveActions.includes(action) && !customNegativeActions.includes(action)
    );
    
    // Créer la section non catégorisées
    const uncategorizedSection = document.createElement('div');
    uncategorizedSection.className = 'uncategorized-section';
    
    const uncategorizedTitle = document.createElement('p');
    uncategorizedTitle.style.cssText = 'color: #7f8c8d; margin-bottom: 15px; font-weight: 600; font-size: 1.1rem;';
    uncategorizedTitle.textContent = 'Actions non catégorisées :';
    uncategorizedSection.appendChild(uncategorizedTitle);
    
    const uncategorizedContainer = document.createElement('div');
    uncategorizedContainer.className = 'uncategorized-actions';
    uncategorizedContainer.style.cssText = `
        min-height: 60px;
        padding: 15px;
        background: rgba(248, 249, 250, 0.8);
        border: 2px dashed #bdc3c7;
        border-radius: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: flex-start;
        width: 100%;
    `;
    
    if (uncategorizedActions.length > 0) {
        uncategorizedActions.forEach(action => {
            const div = createCategoryItem(action, 'uncategorized');
            uncategorizedContainer.appendChild(div);
        });
    } else {
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            width: 100%;
            text-align: center;
            color: #27ae60;
            font-style: italic;
            font-weight: 500;
            padding: 20px;
        `;
        messageDiv.textContent = 'Toutes les actions sont catégorisées';
        uncategorizedContainer.appendChild(messageDiv);
    }
    
    uncategorizedSection.appendChild(uncategorizedContainer);
    
    // Ajouter la section après la grille des catégories (pleine largeur)
    const configSection = positiveContainer.closest('.filters-section');
    configSection.appendChild(uncategorizedSection);
    
    // Rendre les zones droppables
    makeDroppable(positiveContainer, 'positive');
    makeDroppable(negativeContainer, 'negative');
    makeDroppable(uncategorizedContainer, 'uncategorized');
} 
	 
		// Créer un élément de catégorie
		function createCategoryItem(action, category) {
			const div = document.createElement('div');
			div.className = `category-config-item ${category}`;
			div.draggable = true;
			div.dataset.action = action;
			
			// Style spécifique pour les actions non catégorisées
			if (category === 'uncategorized') {
				div.style.cssText += `
					background: #ffffff;
					border: 1px solid #dee2e6;
					color: #6c757d;
				`;
			}
			
			div.innerHTML = `
				<span>${action}</span>
				${category !== 'uncategorized' ? '<button class="remove-from-category" onclick="removeFromCategory(this)">×</button>' : ''}
			`;
			
			// Événements de drag
			div.addEventListener('dragstart', function(e) {
				e.dataTransfer.setData('text/plain', action);
				div.classList.add('dragging');
			});
			
			div.addEventListener('dragend', function(e) {
				div.classList.remove('dragging');
			});
			
			return div;
		}

			// Rendre une zone droppable
		function makeDroppable(container, category) {
			container.addEventListener('dragover', function(e) {
				e.preventDefault();
				if (category !== 'uncategorized') {
					container.classList.add('drag-over');
				}
			});
			
			container.addEventListener('dragleave', function(e) {
				if (category !== 'uncategorized') {
					container.classList.remove('drag-over');
				}
			});
			
			container.addEventListener('drop', function(e) {
				e.preventDefault();
				const action = e.dataTransfer.getData('text/plain');
				if (category !== 'uncategorized') {
					addToCategory(action, category);
					container.classList.remove('drag-over');
				}
			});
		}

        function updatePerformanceRankingChart() {
            const { positiveActions, negativeActions } = categorizeActions();
            const playerStats = {};
            
            // Initialiser les stats des joueurs
            const players = [...new Set(filteredData.map(d => d.Joueur))];
            players.forEach(player => {
                playerStats[player] = { positive: 0, negative: 0, performance: 0 };
            });
            
            // Compter les actions par catégorie pour chaque joueur
            filteredData.forEach(d => {
                if (positiveActions.includes(d.Action)) {
                    playerStats[d.Joueur].positive++;
                } else if (negativeActions.includes(d.Action)) {
                    playerStats[d.Joueur].negative++;
                }
            });

            // Graphique de classement des performances
            const performanceRankingCtx = document.getElementById('performanceRankingChart').getContext('2d');
            if (charts.performanceRanking) charts.performanceRanking.destroy();
            
            charts.performanceRanking = new Chart(performanceRankingCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Score Performance',
                        data: [],
                        backgroundColor: '#6b7280',
                        borderColor: '#4b5563',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { 
                            beginAtZero: true,
                            min: -5,
                            max: 5
                        },
                        y: {
                            ticks: { maxRotation: 0 }
                        }
                    }
                }
            });

            // Graphique d'équilibre
            const balanceCtx = document.getElementById('balanceChart').getContext('2d');
            if (charts.balance) charts.balance.destroy();
            
            charts.balance = new Chart(balanceCtx, {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: [],
                        borderColor: [],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });

            // Calculer le score de performance (différentiel)
            Object.keys(playerStats).forEach(player => {
                playerStats[player].performance = playerStats[player].positive - playerStats[player].negative;
            });

            // Trier par performance décroissante
            const sortedPlayers = Object.entries(playerStats)
                .sort((a, b) => b[1].performance - a[1].performance);

            const ctx = document.getElementById('performanceRankingChart').getContext('2d');
            if (charts.performanceRanking) charts.performanceRanking.destroy();
            
            // Calculer l'échelle dynamiquement
            const performanceValues = sortedPlayers.map(([, stats]) => stats.performance);
            const maxValue = Math.max(...performanceValues.map(Math.abs), 5);
            const scaledMax = Math.ceil(maxValue * 1.1);
            
            // Définir les couleurs selon le score
            const backgroundColors = performanceValues.map(value => {
                if (value > 0) return '#166534'; // Vert foncé
                if (value === 0) return '#000000'; // Noir
                return '#dc2626'; // Rouge vif
            });
            
            const borderColors = performanceValues.map(value => {
                if (value > 0) return '#15803d'; // Vert foncé bordure
                if (value === 0) return '#374151'; // Gris foncé bordure
                return '#991b1b'; // Rouge foncé bordure
            });
            
            charts.performanceRanking = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedPlayers.map(([player]) => player),
                    datasets: [{
                        label: 'Score Performance (Positives - Négatives)',
                        data: performanceValues,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y', // Barres horizontales pour mieux voir les noms
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const playerName = context.label;
                                    const stats = playerStats[playerName];
                                    return `${playerName}: ${stats.performance} (${stats.positive} pos. - ${stats.negative} nég.)`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            min: -scaledMax,
                            max: scaledMax,
                            grid: {
                                color: function(context) {
                                    return context.tick.value === 0 ? '#000000' : '#e5e7eb';
                                }
                            }
                        },
                        y: {
                            ticks: {
                                maxRotation: 0
                            }
                        }
                    }
                }
            });
        }

        function updateBalanceChart() {
            const { positiveActions, negativeActions } = categorizeActions();
            const playerStats = {};
            
            // Calculer les stats par joueur
            const players = [...new Set(filteredData.map(d => d.Joueur))];
            players.forEach(player => {
                playerStats[player] = { positive: 0, negative: 0 };
            });
            
            filteredData.forEach(d => {
                if (positiveActions.includes(d.Action)) {
                    playerStats[d.Joueur].positive++;
                } else if (negativeActions.includes(d.Action)) {
                    playerStats[d.Joueur].negative++;
                }
            });

            // Catégoriser les joueurs selon leur équilibre
            let balanced = 0; // Performance entre -2 et +2
            let positive = 0; // Performance > +2
            let negative = 0; // Performance < -2

            Object.values(playerStats).forEach(stats => {
                const performance = stats.positive - stats.negative;
                if (performance > 2) positive++;
                else if (performance < -2) negative++;
                else balanced++;
            });

            const ctx = document.getElementById('balanceChart').getContext('2d');
            if (charts.balance) charts.balance.destroy();
            
            charts.balance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Équilibrés (-2 à +2)', 'Performants (+2)', 'En difficulté (-2)'],
                    datasets: [{
                        data: [balanced, positive, negative],
                        backgroundColor: ['#6b7280', '#166534', '#dc2626'],
                        borderColor: ['#4b5563', '#15803d', '#991b1b'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed * 100) / total).toFixed(1);
                                    return `${context.label}: ${context.parsed} joueurs (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Ajouter une action à une catégorie
        function addToCategory(action, category) {
            // Retirer de toutes les catégories
            customPositiveActions = customPositiveActions.filter(a => a !== action);
            customNegativeActions = customNegativeActions.filter(a => a !== action);
            
            // Ajouter à la nouvelle catégorie
            if (category === 'positive') {
                customPositiveActions.push(action);
            } else if (category === 'negative') {
                customNegativeActions.push(action);
            }
            
            // Mettre à jour l'affichage et les graphiques
            const allActions = [...new Set(basketballData.map(d => d.Action))].sort();
            updateCategoryConfiguration(allActions);
            updateDashboard();
        }

        // Retirer une action d'une catégorie
        function removeFromCategory(button) {
            const action = button.parentElement.dataset.action;
            customPositiveActions = customPositiveActions.filter(a => a !== action);
            customNegativeActions = customNegativeActions.filter(a => a !== action);
            
            const allActions = [...new Set(basketballData.map(d => d.Action))].sort();
            updateCategoryConfiguration(allActions);
            updateDashboard();
        }

        // Réinitialiser la catégorisation
        function resetCategorization() {
            customPositiveActions = [];
            customNegativeActions = [];
            
            if (basketballData.length > 0) {
                const allActions = [...new Set(basketballData.map(d => d.Action))].sort();
                updateCategoryConfiguration(allActions);
                updateDashboard();
            }
        }
        function applyFilters() {
            const dateFilter = document.getElementById('dateFilter').value;
            const adversaireFilter = document.getElementById('adversaireFilter').value;
            const quartFilter = document.getElementById('quartFilter').value;
            
            const selectedPlayers = Array.from(document.querySelectorAll('#playersCheckboxes input:checked'))
                .map(cb => cb.id.replace('player-', ''));
            
            const selectedActions = Array.from(document.querySelectorAll('#actionsCheckboxes input:checked'))
                .map(cb => cb.id.replace('action-', ''));

            filteredData = basketballData.filter(item => {
                return (!dateFilter || item.Date === dateFilter) &&
                       (!adversaireFilter || item.Adversaire === adversaireFilter) &&
                       (!quartFilter || item['Quart-temps'] === quartFilter) &&
                       (selectedPlayers.length === 0 || selectedPlayers.includes(item.Joueur)) &&
                       (selectedActions.length === 0 || selectedActions.includes(item.Action));
            });

            updateDashboard();
        }

        // Réinitialiser les filtres
        function resetAllFilters() {
            document.getElementById('dateFilter').value = '';
            document.getElementById('adversaireFilter').value = '';
            document.getElementById('quartFilter').value = '';
            
            document.querySelectorAll('#playersCheckboxes input').forEach(cb => {
                cb.checked = true;
                cb.parentElement.classList.add('active');
            });
            
            document.querySelectorAll('#actionsCheckboxes input').forEach(cb => {
                cb.checked = true;
                cb.parentElement.classList.add('active');
            });
            
            filteredData = [...basketballData];
            updateDashboard();
        }

        // Mettre à jour le dashboard
        function updateDashboard() {
            updateStats();
            updateCharts();
            updatePlayersGrid();
        }

        // Catégoriser les actions selon la configuration personnalisée
        function categorizeActions() {
            // Si aucune configuration personnalisée, utiliser les valeurs par défaut
            if (customPositiveActions.length === 0 && customNegativeActions.length === 0) {
                const defaultPositiveActions = ['2 Points', '3 Points', 'Passes décisive', 'Rebond', 'Interceptions'];
                const defaultNegativeActions = ['Fautes', 'Perte de balle'];
                return { positiveActions: defaultPositiveActions, negativeActions: defaultNegativeActions };
            }
            
            return { positiveActions: customPositiveActions, negativeActions: customNegativeActions };
        }

        // Calculer les stats par catégorie
        function calculateCategorizedStats(data) {
            const { positiveActions, negativeActions } = categorizeActions();
            let positiveCount = 0;
            let negativeCount = 0;
            
            data.forEach(d => {
                if (positiveActions.includes(d.Action)) {
                    positiveCount++;
                } else if (negativeActions.includes(d.Action)) {
                    negativeCount++;
                }
            });
            
            return { positiveCount, negativeCount };
        }
       /* function updateStats() {
            const totalActions = filteredData.length;
            const totalPoints = filteredData.filter(d => 
                d.Action === '2 Points' || d.Action === '3 Points'
            ).reduce((sum, d) => sum + parseInt(d.Action.split(' ')[0]), 0);
            
            const activePlayers = new Set(filteredData.map(d => d.Joueur)).size;
            const matches = new Set(filteredData.map(d => `${d.Date}-${d.Adversaire}`)).size;

            document.getElementById('totalActions').textContent = totalActions;
            document.getElementById('totalPoints').textContent = totalPoints;
            document.getElementById('activePlayersCount').textContent = activePlayers;
            document.getElementById('matchesCount').textContent = matches;
        }*/
		
		function updateStats() {
			const totalActions = filteredData.length;
			const totalPoints = filteredData.filter(d => 
				d.Action === '2 Points' || d.Action === '3 Points'
			).reduce((sum, d) => sum + parseInt(d.Action.split(' ')[0]), 0);
			
			// Calculer les actions par catégories
			const { positiveCount, negativeCount } = calculateCategorizedStats(filteredData);
			
			const activePlayers = new Set(filteredData.map(d => d.Joueur)).size;
			const matches = new Set(filteredData.map(d => `${d.Date}-${d.Adversaire}`)).size;

			document.getElementById('totalActions').textContent = totalActions;
			document.getElementById('totalPoints').textContent = totalPoints;
			document.getElementById('positiveActions').textContent = positiveCount;
			document.getElementById('negativeActions').textContent = negativeCount;
			document.getElementById('activePlayersCount').textContent = activePlayers;
			document.getElementById('matchesCount').textContent = matches;
		}

        // Mettre à jour les graphiques
        function updateCharts() {
            updatePlayersChart();
            updateQuartersChart();
            updateActionsChart();
            updateTimelineChart();
            updatePerformanceRankingChart();
            updateBalanceChart();
        }

        function updatePlayersChart() {
            const { positiveActions, negativeActions } = categorizeActions();
            const playerStats = {};
            
            // Initialiser les stats des joueurs
            const players = [...new Set(filteredData.map(d => d.Joueur))];
            players.forEach(player => {
                playerStats[player] = { positive: 0, negative: 0 };
            });
            
            // Compter les actions par catégorie pour chaque joueur
            filteredData.forEach(d => {
                if (positiveActions.includes(d.Action)) {
                    playerStats[d.Joueur].positive++;
                } else if (negativeActions.includes(d.Action)) {
                    playerStats[d.Joueur].negative++;
                }
            });

            const ctx = document.getElementById('playersChart').getContext('2d');
            if (charts.players) charts.players.destroy();
            
            // Calculer l'échelle maximale dynamiquement
            const allValues = Object.values(playerStats).flatMap(stats => [stats.positive, stats.negative]);
            const maxValue = Math.max(...allValues, 5);
            const scaledMax = Math.ceil(maxValue * 1.1);
            
            charts.players = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(playerStats),
                    datasets: [{
                        label: 'Actions Positives',
                        data: Object.values(playerStats).map(stats => stats.positive),
                        backgroundColor: '#2c5aa0',
                        borderColor: '#1e3a8a',
                        borderWidth: 2
                    }, {
                        label: 'Actions Négatives',
                        data: Object.values(playerStats).map(stats => stats.negative),
                        backgroundColor: '#dc2626',
                        borderColor: '#991b1b',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: scaledMax
                        },
                        x: {
                            ticks: {
                                maxRotation: 45
                            }
                        }
                    }
                }
            });
        }

		function updateQuartersChart() {
			const { positiveActions, negativeActions } = categorizeActions();
			const quarterStats = {};
			
			// Initialiser les stats pour chaque quart-temps
			const quarters = [...new Set(filteredData.map(d => d['Quart-temps']))].sort();
			quarters.forEach(quarter => {
				quarterStats[quarter] = { positive: 0, negative: 0 };
			});
			
			// Compter les actions par catégorie pour chaque quart-temps
			filteredData.forEach(d => {
				const quarter = d['Quart-temps'];
				if (positiveActions.includes(d.Action)) {
					quarterStats[quarter].positive++;
				} else if (negativeActions.includes(d.Action)) {
					quarterStats[quarter].negative++;
				}
			});

			const ctx = document.getElementById('quartersChart').getContext('2d');
			if (charts.quarters) charts.quarters.destroy();
			
			// Calculer l'échelle maximale dynamiquement
			const allValues = Object.values(quarterStats).flatMap(stats => [stats.positive, stats.negative]);
			const maxValue = Math.max(...allValues, 5);
			const scaledMax = Math.ceil(maxValue * 1.1);
			
			charts.quarters = new Chart(ctx, {
				type: 'bar',
				data: {
					labels: Object.keys(quarterStats),
					datasets: [{
						label: 'Actions Positives',
						data: Object.values(quarterStats).map(stats => stats.positive),
						backgroundColor: '#2c5aa0',
						borderColor: '#1e3a8a',
						borderWidth: 2
					}, {
						label: 'Actions Négatives',
						data: Object.values(quarterStats).map(stats => stats.negative),
						backgroundColor: '#dc2626',
						borderColor: '#991b1b',
						borderWidth: 2
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: { 
							display: true,
							position: 'top'
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const quarter = context.label;
									const stats = quarterStats[quarter];
									const datasetLabel = context.dataset.label;
									const value = context.parsed.y;
									const total = stats.positive + stats.negative;
									const percentage = total > 0 ? ((value * 100) / total).toFixed(1) : '0.0';
									return `${datasetLabel}: ${value} (${percentage}%)`;
								}
							}
						}
					},
					scales: {
						y: {
							beginAtZero: true,
							max: scaledMax,
							title: {
								display: true,
								text: 'Nombre d\'actions'
							}
						},
						x: {
							title: {
								display: true,
								text: 'Quart-temps'
							}
						}
					}
				}
			});
		}


        function updateActionsChart() {
            const actionStats = {};
            filteredData.forEach(d => {
                if (!actionStats[d.Action]) {
                    actionStats[d.Action] = 0;
                }
                actionStats[d.Action]++;
            });

            const ctx = document.getElementById('actionsChart').getContext('2d');
            if (charts.actions) charts.actions.destroy();
            
            const colors = [
                'rgba(52, 152, 219, 0.8)',
                'rgba(46, 204, 113, 0.8)',
                'rgba(231, 76, 60, 0.8)',
                'rgba(241, 196, 15, 0.8)',
                'rgba(155, 89, 182, 0.8)',
                'rgba(230, 126, 34, 0.8)',
                'rgba(26, 188, 156, 0.8)'
            ];
            
            charts.actions = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: Object.keys(actionStats),
                    datasets: [{
                        data: Object.values(actionStats),
                        backgroundColor: colors.slice(0, Object.keys(actionStats).length),
                        borderColor: colors.slice(0, Object.keys(actionStats).length).map(c => c.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        }
                    }
                }
            });
        }

        function updateTimelineChart() {
            const { positiveActions, negativeActions } = categorizeActions();
            const matchStats = {};
            
            // Grouper par match et compter les actions positives/négatives
            filteredData.forEach(d => {
                const matchKey = `${d.Date} vs ${d.Adversaire}`;
                if (!matchStats[matchKey]) {
                    matchStats[matchKey] = { positive: 0, negative: 0 };
                }
                
                if (positiveActions.includes(d.Action)) {
                    matchStats[matchKey].positive++;
                } else if (negativeActions.includes(d.Action)) {
                    matchStats[matchKey].negative++;
                }
            });

            const ctx = document.getElementById('timelineChart').getContext('2d');
            if (charts.timeline) charts.timeline.destroy();
            
            // Calculer l'échelle maximale dynamiquement
            const allValues = Object.values(matchStats).flatMap(stats => [stats.positive, stats.negative]);
            const maxValue = Math.max(...allValues, 5);
            const scaledMax = Math.ceil(maxValue * 1.2);
            
            const matchLabels = Object.keys(matchStats);
            
            charts.timeline = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: matchLabels,
                    datasets: [{
                        label: 'Actions Positives',
                        data: Object.values(matchStats).map(stats => stats.positive),
                        backgroundColor: 'rgba(44, 90, 160, 0.2)',
                        borderColor: '#2c5aa0',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointBackgroundColor: '#2c5aa0',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 6
                    }, {
                        label: 'Actions Négatives',
                        data: Object.values(matchStats).map(stats => stats.negative),
                        backgroundColor: 'rgba(220, 38, 38, 0.2)',
                        borderColor: '#dc2626',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointBackgroundColor: '#dc2626',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: scaledMax
                        },
                        x: {
                            ticks: { maxRotation: 45 }
                        }
                    }
                }
            });
        }

        // Mettre à jour la grille des joueurs
        function updatePlayersGrid() {
            const playersContainer = document.getElementById('playersGrid');
            const playerStats = {};

            // Calculer les statistiques par joueur
            filteredData.forEach(d => {
                if (!playerStats[d.Joueur]) {
                    playerStats[d.Joueur] = {
                        numero: d.Numéro,
                        totalActions: 0,
                        points: 0,
                        passes: 0,
                        rebonds: 0,
                        fautes: 0,
                        interceptions: 0,
                        pertes: 0
                    };
                }
                
                playerStats[d.Joueur].totalActions++;
                
                switch(d.Action) {
                    case '2 Points':
                        playerStats[d.Joueur].points += 2;
                        break;
                    case '3 Points':
                        playerStats[d.Joueur].points += 3;
                        break;
                    case 'Passes décisive':
                        playerStats[d.Joueur].passes++;
                        break;
                    case 'Rebond':
                        playerStats[d.Joueur].rebonds++;
                        break;
                    case 'Fautes':
                        playerStats[d.Joueur].fautes++;
                        break;
                    case 'Interceptions':
                        playerStats[d.Joueur].interceptions++;
                        break;
                    case 'Perte de balle':
                        playerStats[d.Joueur].pertes++;
                        break;
                }
            });

            if (Object.keys(playerStats).length === 0) {
                playersContainer.innerHTML = '<div class="no-data">Aucune donnée disponible avec les filtres actuels</div>';
                return;
            }

            // Trier par total d'actions
            const sortedPlayers = Object.entries(playerStats)
                .sort((a, b) => b[1].totalActions - a[1].totalActions);

            playersContainer.innerHTML = sortedPlayers.map(([player, stats]) => `
                <div class="player-card">
                    <div class="player-header">
                        <div class="player-name">${player}</div>
                        <div class="player-number">#${stats.numero}</div>
                    </div>
                    <div class="player-stats">
                        <div class="player-stat">
                            <div class="player-stat-value">${stats.points}</div>
                            <div class="player-stat-label">Points</div>
                        </div>
                        <div class="player-stat">
                            <div class="player-stat-value">${stats.passes}</div>
                            <div class="player-stat-label">Passes</div>
                        </div>
                        <div class="player-stat">
                            <div class="player-stat-value">${stats.rebonds}</div>
                            <div class="player-stat-label">Rebonds</div>
                        </div>
                        <div class="player-stat">
                            <div class="player-stat-value">${stats.interceptions}</div>
                            <div class="player-stat-label">Intercep.</div>
                        </div>
                        <div class="player-stat">
                            <div class="player-stat-value">${stats.fautes}</div>
                            <div class="player-stat-label">Fautes</div>
                        </div>
                        <div class="player-stat">
                            <div class="player-stat-value">${stats.pertes}</div>
                            <div class="player-stat-label">Pertes</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Fonction utilitaire pour calculer l'efficacité
        function calculateEfficiency(player) {
            const positiveActions = player.points + player.passes + player.rebonds + player.interceptions;
            const negativeActions = player.fautes + player.pertes;
            return Math.max(0, positiveActions - negativeActions);
        }

        // Fonction d'export des données filtrées
        function exportFilteredData() {
            if (filteredData.length === 0) {
                alert('Aucune donnée à exporter avec les filtres actuels.');
                return;
            }

            const csvContent = "data:text/csv;charset=utf-8," 
                + "Date,Adversaire,Joueur,Numéro,Quart-temps,Temps,Action\n"
                + filteredData.map(row => 
                    `${row.Date},${row.Adversaire},${row.Joueur},${row.Numéro},${row['Quart-temps']},${row.Temps},${row.Action}`
                ).join("\n");

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "analyse_basketball_filtree.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Ajouter le bouton d'export
        function addExportButton() {
            const filtersSection = document.querySelector('.filters-section');
            const exportButton = document.createElement('button');
            exportButton.className = 'reset-filters';
            exportButton.style.marginLeft = '10px';
			exportButton.style.padding = '10px';
			exportButton.style.borderRadius = '5px';
            exportButton.style.background = '#2ecc71';
            exportButton.innerHTML = '📊 Exporter les données filtrées';
            exportButton.onclick = exportFilteredData;
            
            const resetButton = filtersSection.querySelector('.reset-filters');
            resetButton.parentNode.insertBefore(exportButton, resetButton.nextSibling);
        }

        // Fonction pour générer un rapport détaillé
        function generateReport() {
            const report = {
                dateGeneration: new Date().toLocaleDateString('fr-FR'),
                filtresActifs: {
                    date: document.getElementById('dateFilter').value || 'Toutes',
                    adversaire: document.getElementById('adversaireFilter').value || 'Tous',
                    quartTemps: document.getElementById('quartFilter').value || 'Tous'
                },
                statistiquesGenerales: {
                    totalActions: filteredData.length,
                    totalPoints: filteredData.filter(d => 
                        d.Action === '2 Points' || d.Action === '3 Points'
                    ).reduce((sum, d) => sum + parseInt(d.Action.split(' ')[0]), 0),
                    joueursPlusActifs: Object.entries(
                        filteredData.reduce((acc, d) => {
                            acc[d.Joueur] = (acc[d.Joueur] || 0) + 1;
                            return acc;
                        }, {})
                    ).sort((a, b) => b[1] - a[1]).slice(0, 5)
                }
            };

            console.log('📋 Rapport généré:', report);
            return report;
        }

        // Initialisation complète au chargement
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                addExportButton();
            }, 100);
        });

        // Fonctions d'analyse avancée
        function analyzePlayerPerformance(playerName) {
            const playerData = filteredData.filter(d => d.Joueur === playerName);
            
            return {
                totalActions: playerData.length,
                actionsByQuarter: playerData.reduce((acc, d) => {
                    acc[d['Quart-temps']] = (acc[d['Quart-temps']] || 0) + 1;
                    return acc;
                }, {}),
                actionsByType: playerData.reduce((acc, d) => {
                    acc[d.Action] = (acc[d.Action] || 0) + 1;
                    return acc;
                }, {}),
                efficiency: calculatePlayerEfficiency(playerData)
            };
        }

        function calculatePlayerEfficiency(playerData) {
            let points = 0;
            let positiveActions = 0;
            let negativeActions = 0;

            playerData.forEach(d => {
                switch(d.Action) {
                    case '2 Points':
                        points += 2;
                        positiveActions++;
                        break;
                    case '3 Points':
                        points += 3;
                        positiveActions++;
                        break;
                    case 'Passes décisive':
                    case 'Rebond':
                    case 'Interceptions':
                        positiveActions++;
                        break;
                    case 'Fautes':
                    case 'Perte de balle':
                        negativeActions++;
                        break;
                }
            });

            return {
                points,
                positiveActions,
                negativeActions,
                ratio: negativeActions > 0 ? (positiveActions / negativeActions).toFixed(2) : positiveActions
            };
        }

        // Fonction de recherche rapide
        function quickSearch(query) {
            if (!query) return;
            
            const searchResults = basketballData.filter(d => 
                d.Joueur.toLowerCase().includes(query.toLowerCase()) ||
                d.Adversaire.toLowerCase().includes(query.toLowerCase()) ||
                d.Action.toLowerCase().includes(query.toLowerCase())
            );
            
            filteredData = searchResults;
            updateDashboard();
        }

        // Auto-refresh des données (simulation)
        function enableAutoRefresh() {
            setInterval(() => {
                // Ici vous pourriez recharger les données depuis un serveur
                console.log('🔄 Vérification de nouvelles données...');
            }, 30000); // Toutes les 30 secondes
        }

        // Comparaisons entre matchs
        function compareMatches() {
            const matches = [...new Set(filteredData.map(d => `${d.Date}-${d.Adversaire}`))];
            
            if (matches.length < 2) {
                alert('Il faut au moins 2 matchs pour effectuer une comparaison.');
                return;
            }

            const comparison = matches.map(match => {
                const [date, adversaire] = match.split('-');
                const matchData = filteredData.filter(d => d.Date === date && d.Adversaire === adversaire);
                
                return {
                    match: `${date} vs ${adversaire}`,
                    totalActions: matchData.length,
                    points: matchData.filter(d => d.Action.includes('Points'))
                        .reduce((sum, d) => sum + parseInt(d.Action.split(' ')[0]), 0),
                    joueursPlusActifs: matchData.reduce((acc, d) => {
                        acc[d.Joueur] = (acc[d.Joueur] || 0) + 1;
                        return acc;
                    }, {})
                };
            });

            console.log('📊 Comparaison des matchs:', comparison);
            return comparison;
        }

        // Prédictions simples basées sur les tendances
        function predictNextGamePerformance() {
            if (filteredData.length === 0) return null;

            const playerAverages = {};
            const players = [...new Set(filteredData.map(d => d.Joueur))];
            
            players.forEach(player => {
                const playerData = filteredData.filter(d => d.Joueur === player);
                const matches = [...new Set(playerData.map(d => `${d.Date}-${d.Adversaire}`))];
                
                playerAverages[player] = {
                    avgActionsPerGame: (playerData.length / matches.length).toFixed(1),
                    avgPointsPerGame: (playerData.filter(d => d.Action.includes('Points'))
                        .reduce((sum, d) => sum + parseInt(d.Action.split(' ')[0]), 0) / matches.length).toFixed(1)
                };
            });

            return playerAverages;
        }

        // Alertes de performance
        function checkPerformanceAlerts() {
            const alerts = [];
            const playerStats = {};

            filteredData.forEach(d => {
                if (!playerStats[d.Joueur]) {
                    playerStats[d.Joueur] = { fautes: 0, pertes: 0, total: 0 };
                }
                playerStats[d.Joueur].total++;
                if (d.Action === 'Fautes') playerStats[d.Joueur].fautes++;
                if (d.Action === 'Perte de balle') playerStats[d.Joueur].pertes++;
            });

            Object.entries(playerStats).forEach(([player, stats]) => {
                const faultsRatio = stats.fautes / stats.total;
                const turnoversRatio = stats.pertes / stats.total;
                
                if (faultsRatio > 0.3) {
                    alerts.push(`⚠️ ${player}: Taux de fautes élevé (${(faultsRatio * 100).toFixed(1)}%)`);
                }
                
                if (turnoversRatio > 0.2) {
                    alerts.push(`🔄 ${player}: Nombreuses pertes de balle (${(turnoversRatio * 100).toFixed(1)}%)`);
                }
            });

            if (alerts.length > 0) {
                console.warn('🚨 Alertes de performance:', alerts);
            }
            
            return alerts;
        }

        // Activation des fonctionnalités avancées
        setTimeout(() => {
            enableAutoRefresh();
            checkPerformanceAlerts();
        }, 2000);
    </script>
</body>
</html>